document.addEventListener('DOMContentLoaded', () => {
    console.log("Renderer DOMContentLoaded: Script starting.");

    // DOM Element References
    const audioPlayer = document.getElementById('audioPlayer');
    const songNameDisplay = document.getElementById('songName');
    const songNameContainer = document.querySelector('.song-name-container');
    const mainPlayerPanel = document.getElementById('mainPlayerPanel');

    const playPauseBtn = document.getElementById('playPauseBtn');
    const playIcon = '<i class="fas fa-play"></i>';
    const pauseIcon = '<i class="fas fa-pause"></i>';
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const stopBtn = document.getElementById('stopBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const fastForwardBtn = document.getElementById('fastForwardBtn');

    const seekBar = document.getElementById('seekBar');
    const currentTimeDisplay = document.getElementById('currentTime');
    const durationDisplay = document.getElementById('duration');

    const volumeIcon = document.getElementById('volumeIcon');
    const volumeSlider = document.getElementById('volumeSlider');

    const addFilesBtn = document.getElementById('addFilesBtn');
    const playlistContainer = document.getElementById('playlistContainer');
    const playlistUL = document.getElementById('playlist');
    const playlistToggleBtn = document.getElementById('playlistToggleBtn');
    const closePlaylistPanelBtn = document.getElementById('closePlaylistPanelBtn');

    if (!audioPlayer || !songNameDisplay || !songNameContainer || !mainPlayerPanel || !playPauseBtn || !prevBtn || !nextBtn || !stopBtn || !shuffleBtn || !fastForwardBtn || !seekBar || !currentTimeDisplay || !durationDisplay || !volumeIcon || !volumeSlider || !addFilesBtn || !playlistContainer || !playlistUL || !playlistToggleBtn || !closePlaylistPanelBtn) {
        console.error("CRITICAL ERROR: One or more essential DOM elements not found. Check IDs and class selectors in index.html.");
    } else {
        // console.log("All essential DOM elements found.");
    }

    // State Variables
    let playlist = [];
    let currentTrackIndex = -1;
    let isShuffleActive = false;
    let originalPlaylistOrder = [];
    let selectedIndices = [];
    let lastClickedIndex = -1;
    let currentlyPlayingInfo = null; // { path, name, durationFormatted, durationRaw }
    let songScrollTimeout = null;
    let isPlayerExplicitlyStopped = true;

    // --- Helper Functions ---
    function formatTime(seconds) { if (isNaN(seconds) || seconds < 0) seconds = 0; const m = Math.floor(seconds / 60); const s = Math.floor(seconds % 60); return `${m}:${s < 10 ? '0' : ''}${s}`; }
    function getFileName(filePath) { if (!filePath) return 'Unknown Song'; return filePath.split(/[\\/]/).pop() || 'Unknown Song'; }
    function updateVolumeSliderFill() { if (volumeSlider && audioPlayer) { const p = audioPlayer.muted ? 0 : audioPlayer.volume * 100; volumeSlider.style.setProperty('--volume-percent', `${p}%`); } }
    function updateVolumeIcon() { if (!volumeIcon || !audioPlayer) return; volumeIcon.classList.remove('fa-volume-mute', 'fa-volume-off', 'fa-volume-down', 'fa-volume-up'); if (audioPlayer.muted || audioPlayer.volume === 0) { volumeIcon.classList.add('fa-volume-mute'); volumeIcon.title = "Unmute"; } else if (audioPlayer.volume < 0.01) { volumeIcon.classList.add('fa-volume-off'); volumeIcon.title = "Mute"; } else if (audioPlayer.volume <= 0.5) { volumeIcon.classList.add('fa-volume-down'); volumeIcon.title = "Mute"; } else { volumeIcon.classList.add('fa-volume-up'); volumeIcon.title = "Mute"; } }
    async function getAudioDuration(filePath) {
        console.log(`DEBUG: getAudioDuration - START for ${filePath}`);
        return new Promise((resolve) => {
            const tA = new Audio(); tA.preload = 'metadata'; tA.src = filePath; let r = false;
            const rWN = (reason = "unknown") => { if (!r) { r = true; tA.onerror = null; tA.onloadedmetadata = null; tA.oncanplaythrough = null; tA.src = ""; console.log(`DEBUG: getAudioDuration - Resolving NULL for ${filePath} (Reason: ${reason})`); resolve(null); } };
            tA.onloadedmetadata = () => { if (!r) { r = true; tA.onerror = null; tA.oncanplaythrough = null; const d = tA.duration; tA.src = ""; console.log(`DEBUG: getAudioDuration - SUCCESS for ${filePath}, duration: ${d}`); resolve(isNaN(d) ? null : d); } };
            tA.onerror = (e) => { console.error(`DEBUG: getAudioDuration - ONAUDIOERROR for ${getFileName(filePath)}: Code=${e.target.error?.code}, Msg=${e.target.error?.message}`); rWN("audio_element_error"); };
            setTimeout(() => { if (!r) { console.warn(`DEBUG: getAudioDuration - TIMEOUT for ${getFileName(filePath)}`); rWN("timeout"); } }, 7000);
        });
    }
    function checkAndApplySongNameScrolling() { if (!songNameDisplay || !songNameContainer) return; if (songScrollTimeout) { clearTimeout(songScrollTimeout); songScrollTimeout = null; } songNameDisplay.classList.remove('scrolling-active'); songNameDisplay.style.paddingLeft = ''; songNameDisplay.style.textOverflow = 'ellipsis'; songNameDisplay.style.overflow = 'hidden'; void songNameDisplay.offsetWidth; const iO = songNameDisplay.scrollWidth > songNameContainer.clientWidth; if (iO) { songScrollTimeout = setTimeout(() => { if (songNameDisplay.scrollWidth > songNameContainer.clientWidth) { songNameDisplay.style.textOverflow = 'clip'; songNameDisplay.classList.add('scrolling-active'); } else { songNameDisplay.classList.remove('scrolling-active'); songNameDisplay.style.textOverflow = 'ellipsis'; } }, 2000); } else { songNameDisplay.classList.remove('scrolling-active'); songNameDisplay.style.textOverflow = 'ellipsis'; } }

    // --- Audio Player Event Handlers ---
    if (audioPlayer) {
        audioPlayer.addEventListener('loadedmetadata', () => { console.log("Event: loadedmetadata, duration:", audioPlayer.duration); if (durationDisplay && seekBar && currentlyPlayingInfo) { durationDisplay.textContent = formatTime(audioPlayer.duration); seekBar.max = audioPlayer.duration; if (currentlyPlayingInfo.path === audioPlayer.src && (currentlyPlayingInfo.durationRaw == null || isNaN(currentlyPlayingInfo.durationRaw))) { currentlyPlayingInfo.durationRaw = audioPlayer.duration; currentlyPlayingInfo.durationFormatted = formatTime(audioPlayer.duration);}}});
        audioPlayer.addEventListener('timeupdate', () => { if (currentTimeDisplay && seekBar && audioPlayer.duration) { currentTimeDisplay.textContent = formatTime(audioPlayer.currentTime); seekBar.value = audioPlayer.currentTime; } });
        audioPlayer.addEventListener('play', () => { console.log("Event: audioPlayer.onplay - src:", audioPlayer.src); if (audioPlayer.src && audioPlayer.src !== '' && !audioPlayer.src.endsWith('index.html')) { isPlayerExplicitlyStopped = false; } if (playPauseBtn) playPauseBtn.innerHTML = pauseIcon; });
        audioPlayer.addEventListener('pause', () => { console.log("Event: audioPlayer.onpause - src:", audioPlayer.src); if (playPauseBtn) playPauseBtn.innerHTML = playIcon; });
        audioPlayer.addEventListener('ended', () => { console.log("Event: audioPlayer.onended - src:", audioPlayer.src); currentlyPlayingInfo = null; isPlayerExplicitlyStopped = true; if (audioPlayer) audioPlayer.src = ''; playNextTrackLogic(); });
        audioPlayer.addEventListener('error', (e) => {
            console.error('Audio player error event. Message:', e.target.error?.message, "Code:", e.target.error?.code, "Current src:", audioPlayer.src, "Errored src:", e.target.src);
            const erroredSrc = e.target.src; const cpiPathBeforeError = currentlyPlayingInfo?.path;
            currentlyPlayingInfo = null; isPlayerExplicitlyStopped = true;
            if (audioPlayer && audioPlayer.src === erroredSrc && audioPlayer.src !== '') { audioPlayer.src = ''; audioPlayer.load(); }
            if (songNameDisplay) { const trackName = playlist.find(t => t.path === cpiPathBeforeError)?.name || (erroredSrc ? getFileName(erroredSrc) : "track"); songNameDisplay.textContent = `Error: Could not play (${trackName || 'Unknown'})`; songNameDisplay.title = songNameDisplay.textContent; checkAndApplySongNameScrolling(); }
        });
        audioPlayer.addEventListener('volumechange', () => { updateVolumeSliderFill(); updateVolumeIcon(); if (window.electronAPI && typeof window.electronAPI.saveVolume === 'function') { window.electronAPI.saveVolume(audioPlayer.volume); } });
    }

    // --- UI Control Event Handlers ---
    if (playPauseBtn) { playPauseBtn.addEventListener('click', () => { console.log("Play/Pause CLICKED. Player src:", audioPlayer?.src, "Paused:", audioPlayer?.paused, "StoppedFlag:", isPlayerExplicitlyStopped, "CPI:", !!currentlyPlayingInfo); if (audioPlayer) { if (audioPlayer.paused) { const hasValidSrcAndInfo = audioPlayer.src && audioPlayer.src !== '' && !audioPlayer.src.endsWith('index.html') && currentlyPlayingInfo; if (isPlayerExplicitlyStopped && !hasValidSrcAndInfo) { if (playlist.length > 0) { let indexToPlay = (currentTrackIndex !== -1 && currentTrackIndex < playlist.length) ? currentTrackIndex : 0; if (playlist[indexToPlay]) { playTrack(indexToPlay, "playPauseBtn_stopped_emptySrc_playlistHasItems"); } else { console.log("Play/Pause: Was explicitly stopped, src invalid/empty, no valid playlist item at index", indexToPlay); } } else { console.log("Play/Pause: Was explicitly stopped, src invalid/empty, playlist empty. No action."); } } else if (hasValidSrcAndInfo) { audioPlayer.play().catch(e => { console.error("Play error from playPauseBtn (existing src):", e); if(songNameDisplay) songNameDisplay.textContent = "Error: Could not play."; checkAndApplySongNameScrolling();}); } else if (playlist.length > 0) { let indexToPlay = (currentTrackIndex !== -1 && currentTrackIndex < playlist.length) ? currentTrackIndex : 0; if (playlist[indexToPlay]) { playTrack(indexToPlay, "playPauseBtn_paused_emptySrc_playlistHasItems"); } else { console.log("Play/Pause: No valid current src and no valid playlist item to play from at index", indexToPlay); } } else { console.log("Play/Pause: Player paused, no valid src, and playlist is empty. Doing nothing."); } } else { audioPlayer.pause(); } } }); }
    if (stopBtn) { stopBtn.addEventListener('click', () => { console.log("Stop button CLICKED. Current audio src BEFORE stop:", audioPlayer?.src); isPlayerExplicitlyStopped = true; if (audioPlayer) { audioPlayer.pause(); audioPlayer.removeAttribute('src'); audioPlayer.load(); audioPlayer.currentTime = 0; console.log("Audio player stopped. Actual src after clear/load:", audioPlayer.src); } currentlyPlayingInfo = null; if (songNameDisplay) { songNameDisplay.textContent = "None"; songNameDisplay.title = "None"; checkAndApplySongNameScrolling(); } if (durationDisplay && seekBar) { durationDisplay.textContent = formatTime(0); if (seekBar) { seekBar.value = 0; seekBar.max = 0; } } if (playPauseBtn) { playPauseBtn.innerHTML = playIcon; } renderPlaylist(); console.log("Stop button logic finished."); }); }
    if (fastForwardBtn) { fastForwardBtn.addEventListener('click', () => { if (audioPlayer && audioPlayer.src && !isNaN(audioPlayer.duration) && audioPlayer.readyState >= 2) { audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 10); } else { console.warn("Fast Forward: Conditions not met. Src:", audioPlayer?.src, "Duration:", audioPlayer?.duration, "ReadyState:", audioPlayer?.readyState); } }); }
    if (seekBar) { seekBar.addEventListener('input', () => { if (audioPlayer && audioPlayer.src && !isNaN(audioPlayer.duration) && audioPlayer.readyState >= 2) { audioPlayer.currentTime = parseFloat(seekBar.value); } else { console.warn("Seek: Conditions not met. Src:", audioPlayer?.src, "Duration:", audioPlayer?.duration, "ReadyState:", audioPlayer?.readyState); } }); }
    if (volumeSlider) { volumeSlider.addEventListener('input', () => { if (audioPlayer) { audioPlayer.muted = false; audioPlayer.volume = parseFloat(volumeSlider.value); } }); }
    if (volumeIcon) { volumeIcon.addEventListener('click', () => { if (audioPlayer) { audioPlayer.muted = !audioPlayer.muted; if (!audioPlayer.muted && audioPlayer.volume === 0) { const dUV = 0.1; audioPlayer.volume = dUV; if (volumeSlider) volumeSlider.value = dUV.toString(); } updateVolumeIcon(); updateVolumeSliderFill(); } }); }

    // --- Playlist Logic Functions ---
    function renderPlaylist() { if (!playlistUL) return; playlistUL.innerHTML = ''; selectedIndices = selectedIndices.filter(idx => idx < playlist.length); if (playlist.length === 0) { const li = document.createElement('li'); li.className = 'playlist-drop-target'; li.textContent = 'Drag & drop audio files here or use "Add Files"'; playlistUL.appendChild(li); return; } playlist.forEach((track, index) => { const li = document.createElement('li'); const tNS = document.createElement('span'); tNS.className = 'track-name-span'; tNS.textContent = track.name; tNS.title = track.name; li.appendChild(tNS); const dS = document.createElement('span'); dS.className = 'track-duration-span'; dS.textContent = track.durationFormatted || "--:--"; li.appendChild(dS); li.dataset.index = index; li.classList.remove('playing-actual', 'selected-ui', 'selected'); if (currentlyPlayingInfo && currentlyPlayingInfo.path === track.path && !audioPlayer.paused && !audioPlayer.ended && !isPlayerExplicitlyStopped) { li.classList.add('playing-actual'); } if (index === currentTrackIndex) { li.classList.add('selected-ui'); } if (selectedIndices.includes(index)) li.classList.add('selected'); li.addEventListener('click', (e) => handlePlaylistItemClick(e, index)); li.addEventListener('contextmenu', (e) => { e.preventDefault(); if (!selectedIndices.includes(index)) { if (!e.ctrlKey && !e.metaKey && !e.shiftKey) selectedIndices = [index]; else selectedIndices.push(index); renderPlaylist(); } if (window.electronAPI && typeof window.electronAPI.showPlaylistContextMenu === 'function') { window.electronAPI.showPlaylistContextMenu(index, [...selectedIndices]); } else { console.warn("showPlaylistContextMenu API not available."); } }); playlistUL.appendChild(li); }); }
    function handlePlaylistItemClick(event, index) { if (event.shiftKey && lastClickedIndex !== -1) { selectedIndices = []; const s = Math.min(index, lastClickedIndex), e = Math.max(index, lastClickedIndex); for (let i = s; i <= e; i++) selectedIndices.push(i); } else if (event.ctrlKey || event.metaKey) { const p = selectedIndices.indexOf(index); if (p > -1) selectedIndices.splice(p, 1); else selectedIndices.push(index); } else { currentTrackIndex = index; selectedIndices = [index]; playTrack(index, "playlistItemClick"); } lastClickedIndex = index; if (event.ctrlKey || event.metaKey || event.shiftKey) { renderPlaylist(); } }
    async function addFilesToPlaylist(filePaths, playFirstNew = false) { console.log("DEBUG: addFilesToPlaylist - START. Paths:", filePaths, "PlayFirst:", playFirstNew); const oldPlaylistLength = playlist.length; let firstNewTrackActualIndexInPlaylist = -1; const originalSongNameOnDisplay = songNameDisplay ? songNameDisplay.textContent : "None"; if (songNameDisplay) songNameDisplay.textContent = "Loading songs..."; for (let i = 0; i < filePaths.length; i++) { const path = filePaths[i]; const name = getFileName(path); console.log(`DEBUG: addFilesToPlaylist - Processing file ${i+1}/${filePaths.length}: ${name}`); if (songNameDisplay && filePaths.length > 1) songNameDisplay.textContent = `Loading: ${name} (${i+1}/${filePaths.length})`; const durationRaw = await getAudioDuration(path); const durationFormatted = durationRaw != null && !isNaN(durationRaw) ? formatTime(durationRaw) : "--:--"; console.log(`DEBUG: addFilesToPlaylist - Got duration for ${name}: ${durationFormatted} (raw: ${durationRaw})`); const newTrack = { path, name, durationRaw, durationFormatted }; playlist.push(newTrack); if (isShuffleActive && originalPlaylistOrder) { originalPlaylistOrder.push({ ...newTrack }); } if (firstNewTrackActualIndexInPlaylist === -1) { firstNewTrackActualIndexInPlaylist = playlist.length - 1; } console.log(`DEBUG: addFilesToPlaylist - Added to playlist array:`, newTrack); } console.log("DEBUG: addFilesToPlaylist - Finished processing all files for batch."); if (songNameDisplay) { if (currentlyPlayingInfo) { songNameDisplay.textContent = currentlyPlayingInfo.name; } else if ((playFirstNew || oldPlaylistLength === 0) && firstNewTrackActualIndexInPlaylist !== -1 && playlist[firstNewTrackActualIndexInPlaylist]) { songNameDisplay.textContent = playlist[firstNewTrackActualIndexInPlaylist].name; } else { songNameDisplay.textContent = originalSongNameOnDisplay; } } checkAndApplySongNameScrolling(); renderPlaylist(); console.log("DEBUG: addFilesToPlaylist - Playlist rendered."); if ((playFirstNew || oldPlaylistLength === 0) && firstNewTrackActualIndexInPlaylist !== -1) { console.log("DEBUG: addFilesToPlaylist - Attempting to play first new track at index:", firstNewTrackActualIndexInPlaylist); playTrack(firstNewTrackActualIndexInPlaylist, "addFilesToPlaylist_playFirstNew"); } console.log("DEBUG: addFilesToPlaylist - END"); }
    
    function playTrack(index, calledFrom = "unknown") {
        console.log(`DEBUG: playTrack - CALLED from "${calledFrom}" with index: ${index}, Playlist length: ${playlist.length}, ExplicitlyStopped: ${isPlayerExplicitlyStopped}, Current player src: "${audioPlayer?.src}"`);
        if (!audioPlayer || !songNameDisplay) { console.warn("DEBUG: playTrack - audioPlayer or songNameDisplay not found, exiting."); return; }
        currentTrackIndex = index;
        if (index >= 0 && index < playlist.length) {
            selectedIndices = [index]; lastClickedIndex = index;
            const trackToLoad = playlist[index];
            console.log(`DEBUG: playTrack - Attempting to load track: "${trackToLoad?.name}", Path: "${trackToLoad?.path}"`);
            if (trackToLoad && typeof trackToLoad.path === 'string' && trackToLoad.path.trim() !== '') {
                const needsNewSrc = currentlyPlayingInfo?.path !== trackToLoad.path || isPlayerExplicitlyStopped || audioPlayer.error || audioPlayer.ended || !audioPlayer.src || audioPlayer.src === '' || audioPlayer.src.endsWith('index.html') || audioPlayer.src === window.location.href + "#";
                if (needsNewSrc) {
                    console.log(`DEBUG: playTrack - Condition met (needsNewSrc=${needsNewSrc}). Setting new src to "${trackToLoad.path}" for track: "${trackToLoad.name}"`);
                    // isPlayerExplicitlyStopped = false; // Will be set by 'play' event
                    audioPlayer.src = trackToLoad.path;
                    currentlyPlayingInfo = { ...trackToLoad };
                    songNameDisplay.textContent = trackToLoad.name; songNameDisplay.title = trackToLoad.name;
                    checkAndApplySongNameScrolling();
                    console.log(`DEBUG: playTrack - Calling audioPlayer.play() for "${trackToLoad.name}"`);
                    const playPromise = audioPlayer.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => { console.log(`DEBUG: playTrack - Play promise RESOLVED for "${trackToLoad.name}"`); /* isPlayerExplicitlyStopped is set by 'play' event */ }).catch(e => { console.error(`DEBUG: playTrack - Play promise REJECTED for "${trackToLoad.name}". Error:`, e.message, e); songNameDisplay.textContent = `Error: Could not play (${trackToLoad.name || 'track'})`; checkAndApplySongNameScrolling(); currentlyPlayingInfo = null; isPlayerExplicitlyStopped = true; if(audioPlayer) { audioPlayer.src = ''; audioPlayer.load(); } });
                    } else { console.warn("DEBUG: playTrack - audioPlayer.play() did not return a promise. This is unexpected."); isPlayerExplicitlyStopped = true; }
                } else {
                    console.log(`DEBUG: playTrack - Track already loaded/src is same and valid: "${trackToLoad.name}". Player paused: ${audioPlayer.paused}`);
                    songNameDisplay.textContent = trackToLoad.name; songNameDisplay.title = trackToLoad.name; checkAndApplySongNameScrolling();
                    if (audioPlayer.paused) { console.log(`DEBUG: playTrack - Resuming paused track: "${trackToLoad.name}"`); audioPlayer.play().catch(e => { console.error(`DEBUG: Error re-playing (resuming) track: "${trackToLoad.name}"`, e); isPlayerExplicitlyStopped = true; }); }
                }
            } else { console.error(`DEBUG: playTrack - Invalid track data (no path or empty path) at UI index: ${index}`, trackToLoad); if (!currentlyPlayingInfo && songNameDisplay) { songNameDisplay.textContent = `Error: Invalid track data.`; checkAndApplySongNameScrolling(); } }
        } else {
            console.log(`DEBUG: playTrack - Index invalid (${index}) or playlist empty (length ${playlist.length}). Player state: Src="${audioPlayer.src}", Stopped="${isPlayerExplicitlyStopped}", Ended="${audioPlayer.ended}", Error="${!!audioPlayer.error}"`);
            if (isPlayerExplicitlyStopped || (!audioPlayer.src || audioPlayer.src === '' || audioPlayer.src.endsWith('index.html') || audioPlayer.src === window.location.href + "#") ) {
                console.log("DEBUG: playTrack - Resetting player UI - nothing should play as player is stopped and src is invalid/empty.");
                if (audioPlayer) { audioPlayer.pause(); audioPlayer.removeAttribute('src'); audioPlayer.load(); }
                currentlyPlayingInfo = null;
                if (songNameDisplay) { songNameDisplay.textContent = 'None'; songNameDisplay.title = 'None'; } checkAndApplySongNameScrolling();
                if (durationDisplay && seekBar) { durationDisplay.textContent = formatTime(0); seekBar.value = 0; seekBar.max = 0; }
                currentTrackIndex = -1; isPlayerExplicitlyStopped = true;
            } else { console.log("DEBUG: playTrack - Lingering track (src:", audioPlayer.src, ") detected, not changing player state from playTrack due to invalid index."); }
        }
        renderPlaylist();
    }
    function removeTracks(indicesToRemove) { if (!indicesToRemove || indicesToRemove.length === 0) return; indicesToRemove.sort((a, b) => b - a); let newUiCurrentIndex = currentTrackIndex; indicesToRemove.forEach(indexToRemove => { if (indexToRemove < 0 || indexToRemove >= playlist.length) return; const removedTrack = playlist.splice(indexToRemove, 1)[0]; if (isShuffleActive && originalPlaylistOrder) { const oI = originalPlaylistOrder.findIndex(t => t.path === removedTrack?.path); if (oI > -1) originalPlaylistOrder.splice(oI, 1); } if (indexToRemove === newUiCurrentIndex) {} else if (indexToRemove < newUiCurrentIndex) { newUiCurrentIndex--; } }); if (playlist.length === 0) { currentTrackIndex = -1; } else { currentTrackIndex = Math.min(newUiCurrentIndex, playlist.length - 1); if (currentTrackIndex < 0) currentTrackIndex = 0; } selectedIndices = (currentTrackIndex !== -1) ? [currentTrackIndex] : []; lastClickedIndex = currentTrackIndex; if (currentlyPlayingInfo && songNameDisplay) { songNameDisplay.textContent = currentlyPlayingInfo.name; songNameDisplay.title = currentlyPlayingInfo.name; } else if (playlist.length > 0 && currentTrackIndex !== -1 && songNameDisplay) { songNameDisplay.textContent = playlist[currentTrackIndex].name; songNameDisplay.title = playlist[currentTrackIndex].name; } else if (songNameDisplay) { songNameDisplay.textContent = "None"; songNameDisplay.title = "None"; if (audioPlayer && (!audioPlayer.src || audioPlayer.src === '') && !currentlyPlayingInfo) { if (durationDisplay && seekBar) { durationDisplay.textContent = formatTime(0); seekBar.value = 0; seekBar.max = 0; } } } checkAndApplySongNameScrolling(); renderPlaylist(); }
    function playNextTrackLogic() { console.log("playNextTrackLogic called. UI Index:", currentTrackIndex, "Playlist length:", playlist.length); if (playlist.length === 0) { if (audioPlayer) { audioPlayer.pause(); audioPlayer.removeAttribute('src'); audioPlayer.load(); } currentlyPlayingInfo = null; isPlayerExplicitlyStopped = true; if (songNameDisplay) { songNameDisplay.textContent = "None"; songNameDisplay.title = "None"; checkAndApplySongNameScrolling(); } if (durationDisplay && seekBar) { durationDisplay.textContent = formatTime(0); seekBar.value = 0; seekBar.max = 0; } currentTrackIndex = -1; renderPlaylist(); return; } let newIndex = currentTrackIndex + 1; if (newIndex >= playlist.length) { newIndex = 0; } playTrack(newIndex, "playNextTrackLogic"); }
    function playPrevTrackLogic() { console.log("playPrevTrackLogic called. UI Index:", currentTrackIndex, "Playlist length:", playlist.length); if (playlist.length === 0) { if (audioPlayer) { audioPlayer.pause(); audioPlayer.removeAttribute('src'); audioPlayer.load(); } currentlyPlayingInfo = null; isPlayerExplicitlyStopped = true; if (songNameDisplay) { songNameDisplay.textContent = "None"; songNameDisplay.title = "None"; checkAndApplySongNameScrolling(); } if (durationDisplay && seekBar) { durationDisplay.textContent = formatTime(0); seekBar.value = 0; seekBar.max = 0; } currentTrackIndex = -1; renderPlaylist(); return; } let newIndex = currentTrackIndex - 1; if (newIndex < 0) { newIndex = playlist.length - 1; } playTrack(newIndex, "playPrevTrackLogic"); }
    function updateShuffleButtonUI() { if (!shuffleBtn) return; shuffleBtn.classList.toggle('shuffle-active', isShuffleActive); shuffleBtn.innerHTML = `<i class="fas fa-random"></i>`; shuffleBtn.title = isShuffleActive ? "Shuffle: On" : "Shuffle: Off"; }
    function shuffleCurrentPlaylist() { if (playlist.length < 2) return; const cPIS = currentlyPlayingInfo ? {...currentlyPlayingInfo} : null; if (!originalPlaylistOrder || originalPlaylistOrder.length === 0 || playlist.some((track, i) => track.path !== originalPlaylistOrder[i]?.path) ) { originalPlaylistOrder = playlist.map(track => ({ ...track })); } for (let i = playlist.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [playlist[i], playlist[j]] = [playlist[j], playlist[i]]; } if (cPIS) { currentTrackIndex = playlist.findIndex(track => track.path === cPIS.path); if (currentTrackIndex === -1 && playlist.length > 0) { currentTrackIndex = 0; } } else if (playlist.length > 0) { currentTrackIndex = 0; } else { currentTrackIndex = -1; } selectedIndices = currentTrackIndex > -1 ? [currentTrackIndex] : []; lastClickedIndex = currentTrackIndex; }
    function unshufflePlaylist() { if (originalPlaylistOrder && originalPlaylistOrder.length > 0) { const cPIS = currentlyPlayingInfo ? {...currentlyPlayingInfo} : null; playlist = originalPlaylistOrder.map(track => ({ ...track })); if (cPIS) { currentTrackIndex = playlist.findIndex(track => track.path === cPIS.path); if (currentTrackIndex === -1 && playlist.length > 0) currentTrackIndex = 0; } else if (playlist.length > 0) { currentTrackIndex = 0; } else { currentTrackIndex = -1; } selectedIndices = currentTrackIndex > -1 ? [currentTrackIndex] : []; lastClickedIndex = currentTrackIndex; } }

    // --- Event Listeners Attached AFTER Function Declarations ---
    if (prevBtn) prevBtn.addEventListener('click', playPrevTrackLogic);
    if (nextBtn) nextBtn.addEventListener('click', playNextTrackLogic);
    if (shuffleBtn) { shuffleBtn.addEventListener('click', () => { isShuffleActive = !isShuffleActive; console.log("Shuffle toggled. isShuffleActive:", isShuffleActive); if (isShuffleActive) { shuffleCurrentPlaylist(); } else { unshufflePlaylist(); } updateShuffleButtonUI(); renderPlaylist(); }); }
    if (addFilesBtn) { console.log("Renderer DEBUG: Attaching 'click' listener to addFilesBtn."); addFilesBtn.addEventListener('click', async () => { console.log("Renderer DEBUG: Add Files button CLICKED."); try { if (window.electronAPI && typeof window.electronAPI.openFiles === 'function') { console.log("Renderer DEBUG: Calling window.electronAPI.openFiles()"); const filePaths = await window.electronAPI.openFiles(); console.log("Renderer DEBUG: Files selected via dialog:", filePaths); if (filePaths && filePaths.length > 0) { console.log("Renderer DEBUG: Calling addFilesToPlaylist with selected files."); await addFilesToPlaylist(filePaths, playlist.length === 0); console.log("Renderer DEBUG: addFilesToPlaylist completed after Add Files button click."); } else { console.log("Renderer DEBUG: No files selected or dialog cancelled."); } } else { console.error("Renderer DEBUG Error: window.electronAPI.openFiles is not available."); } } catch (error) { console.error("Renderer DEBUG Error in addFilesBtn click handler:", error); } }); } else { console.error("Renderer DEBUG ERROR: addFilesBtn element NOT FOUND! Check ID in HTML."); }
    function updatePlaylistToggleBtnTextDOM() { if (!playlistToggleBtn || !playlistContainer) { return; } const isHidden = playlistContainer.classList.contains('hidden'); playlistToggleBtn.innerHTML = `<i class="fas fa-list-ul"></i> ${isHidden ? 'Show' : 'Hide'} Playlist`; playlistToggleBtn.title = `${isHidden ? 'Show' : 'Hide'} Playlist`; }
    function setPlaylistUIVisibilityDOM(isVisible) { if (!playlistContainer) { return; } if (isVisible) { playlistContainer.classList.remove('hidden'); if(mainPlayerPanel) mainPlayerPanel.classList.add('with-playlist');} else { playlistContainer.classList.add('hidden'); if(mainPlayerPanel) mainPlayerPanel.classList.remove('with-playlist');} updatePlaylistToggleBtnTextDOM(); }
    function toggleDockedPlaylistDOM() { console.log("Renderer DEBUG: toggleDockedPlaylistDOM CALLED."); if (!playlistContainer) { console.error("Renderer DEBUG Error: playlistContainer is null in toggleDockedPlaylistDOM."); return; } const isCurrentlyHidden = playlistContainer.classList.contains('hidden'); const showPlaylist = isCurrentlyHidden; const currentBodyWidth = document.body.offsetWidth; setPlaylistUIVisibilityDOM(showPlaylist); if (window.electronAPI && typeof window.electronAPI.resizeMainWindowAndSaveVisibility === 'function') { const heightOption = showPlaylist ? 'player_with_playlist' : 'player_only'; console.log("Renderer DEBUG: toggleDockedPlaylistDOM: Sending IPC. Width:", currentBodyWidth, "HeightOpt:", heightOption, "Visible:", showPlaylist); window.electronAPI.resizeMainWindowAndSaveVisibility(currentBodyWidth, heightOption, showPlaylist); } else { console.error("Renderer DEBUG Error: window.electronAPI.resizeMainWindowAndSaveVisibility is not available."); } }
    if (playlistToggleBtn) { console.log("Renderer DEBUG: Attaching 'click' listener to playlistToggleBtn."); playlistToggleBtn.addEventListener('click', toggleDockedPlaylistDOM); } else { console.error("Renderer DEBUG ERROR: playlistToggleBtn element NOT FOUND!"); }
    if (closePlaylistPanelBtn) { closePlaylistPanelBtn.addEventListener('click', () => { console.log("Renderer DEBUG: closePlaylistPanelBtn CLICKED."); if (playlistContainer && !playlistContainer.classList.contains('hidden')) { toggleDockedPlaylistDOM(); } }); } else { console.error("Renderer DEBUG ERROR: closePlaylistPanelBtn element NOT FOUND!"); }
    const dropZoneElement = document.body; if (dropZoneElement) { console.log("Renderer DEBUG: Attaching drag/drop listeners to body."); dropZoneElement.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); if (playlistContainer && !playlistContainer.classList.contains('hidden')) { playlistContainer.classList.add('dragover-active'); if (playlistUL && playlistUL.querySelector('.playlist-drop-target')) { playlistUL.querySelector('.playlist-drop-target').classList.add('dragover'); } } else { if (mainPlayerPanel) mainPlayerPanel.classList.add('dragover-body'); } }); dropZoneElement.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); if (playlistContainer) playlistContainer.classList.remove('dragover-active'); if (playlistUL && playlistUL.querySelector('.playlist-drop-target.dragover')) { playlistUL.querySelector('.playlist-drop-target.dragover').classList.remove('dragover'); } if (mainPlayerPanel) mainPlayerPanel.classList.remove('dragover-body'); }); dropZoneElement.addEventListener('drop', async (e) => { console.log("Renderer DEBUG: Files DROPPED."); e.preventDefault(); e.stopPropagation(); if (playlistContainer) playlistContainer.classList.remove('dragover-active'); if (playlistUL && playlistUL.querySelector('.playlist-drop-target.dragover')) { playlistUL.querySelector('.playlist-drop-target.dragover').classList.remove('dragover'); } if (mainPlayerPanel) mainPlayerPanel.classList.remove('dragover-body'); const files = e.dataTransfer.files; if (files && files.length > 0) { const audioFilePaths = Array.from(files).filter(f => f.type.startsWith('audio/') || /\.(mp3|wav|ogg|m4a|flac|aac)$/i.test(f.name)).map(f => f.path); console.log("Renderer DEBUG: Paths from drop:", audioFilePaths); if (audioFilePaths.length > 0) { await addFilesToPlaylist(audioFilePaths, playlist.length === 0); console.log("Renderer DEBUG: addFilesToPlaylist completed for drop."); } } else { console.log("Renderer DEBUG: No files in drop dataTransfer."); } }); }
    
    // --- IPC Event Handlers ---
    if (window.electronAPI && typeof window.electronAPI.onContextMenuCommand === 'function') { window.electronAPI.onContextMenuCommand((command, data) => { if (command === 'remove-tracks') removeTracks(data); }); }
    if (window.electronAPI && typeof window.electronAPI.onSetInitialPlaylistVisibility === 'function') { window.electronAPI.onSetInitialPlaylistVisibility((isVisible) => setPlaylistUIVisibilityDOM(isVisible)); }
    if (window.electronAPI && typeof window.electronAPI.onSetInitialVolume === 'function') { window.electronAPI.onSetInitialVolume((initialVolume) => { if (audioPlayer && typeof initialVolume === 'number') audioPlayer.volume = initialVolume; if (volumeSlider && typeof initialVolume === 'number') volumeSlider.value = initialVolume.toString(); }); }
    if (window.electronAPI && typeof window.electronAPI.onOpenFileInPlayer === 'function') { window.electronAPI.onOpenFileInPlayer(async (filePath) => { console.log("Renderer DEBUG: IPC 'onOpenFileInPlayer' RECEIVED path:", filePath); if (filePath && typeof filePath === 'string') { const trackExistsIndex = playlist.findIndex(track => track.path === filePath); if (trackExistsIndex !== -1) { console.log("Renderer DEBUG: File association - File already in playlist, playing index:", trackExistsIndex); isPlayerExplicitlyStopped = false; playTrack(trackExistsIndex, "onOpenFileInPlayer_existing"); } else { console.log("Renderer DEBUG: File association - File not in playlist, adding..."); if(songNameDisplay && playlist.length === 0) songNameDisplay.textContent = `Loading: ${getFileName(filePath)}`; checkAndApplySongNameScrolling(); const name = getFileName(filePath); console.log("Renderer DEBUG: File association - Getting duration for", name); const durationRaw = await getAudioDuration(filePath); const durationFormatted = durationRaw != null && !isNaN(durationRaw) ? formatTime(durationRaw) : "--:--"; const newTrack = { path: filePath, name, durationRaw, durationFormatted }; playlist.push(newTrack); console.log("Renderer DEBUG: File association - New track pushed to playlist:", newTrack); renderPlaylist(); const newTrackIndex = playlist.length - 1; console.log("Renderer DEBUG: File association - New track added at index:", newTrackIndex, ". Explicitly calling playTrack."); isPlayerExplicitlyStopped = false; playTrack(newTrackIndex, "onOpenFileInPlayer_new"); } } else { console.warn("Renderer DEBUG: Received invalid filePath for 'onOpenFileInPlayer':", filePath); } }); } else { console.warn("Renderer DEBUG: window.electronAPI.onOpenFileInPlayer not available."); }

    // --- Initial Setup ---
    console.log("Renderer DEBUG: Initial Setup starting.");
    renderPlaylist(); updatePlaylistToggleBtnTextDOM(); updateShuffleButtonUI();
    setTimeout(() => {
        console.log("Renderer DEBUG: Initial Setup timeout function running (for volume UI).");
        if (audioPlayer && volumeSlider && typeof audioPlayer.volume === 'number' && typeof volumeSlider.value === 'string') { if (audioPlayer.volume.toFixed(2) !== parseFloat(volumeSlider.value).toFixed(2)) { if (volumeSlider) volumeSlider.value = audioPlayer.volume.toString(); } }
        updateVolumeSliderFill(); updateVolumeIcon(); checkAndApplySongNameScrolling();
        console.log("Renderer DEBUG: Initial Setup timeout function completed.");
    }, 100);
    console.log("Renderer DEBUG: Script fully loaded and initial setup queued.");
});